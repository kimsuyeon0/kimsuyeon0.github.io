---
layout: post
title: 01. 쿠버네티스?
---

# 01. 쿠버네티스?

쿠버네티스는 하드웨어 인프라를 추상화하여 전체 데이터 센터를 하나의 거대한 계산 리소스로 제공한다.
개발자는 운영 팀의 도움을 받지 않고 애플리케이션을 원하는 만큼 자주 배포할 수 있다.

기존의 모놀리식 애플리케이션의 경우에는 애플리케이션을 조금만 변경해도 다시 배포해야하므로 점점 더 복잡해지고, 시스템의 품질이 저하되는데 **마이크로서비스**로 독립적으로 배포가능한 요소로 쪼개어 독립적인 프로세스로 실행되게 해야한다.
독립프로세스는 **RESTful API** 를 제공하기 위해 HTTP(동기 프로토콜), AMQ(비동기 프로토콜)을 이용하여 통신하게 된다.

#### 왜 컨테이너 기술을 사용해야할까?

- VM을 각 구성 요소에 사용할 경우 환경을 격리할 수 있지만, 요소가 많아지면 하드웨어 리소스 낭비, 작업부하, 인적자원 낭비가 발생한다.
- 리눅스 컨테이너 기술을 사용할 경우, 같은 호스트 시스템에서 여러 서비스를 실행할 수 있고 VM에 비해서 오버헤드가 적다.
- 컨테이너의 경우 부팅을 할 필요가 없다. 컨테이너 시작=프로세스 시작

#### 컨테이너 격리 매커니즘
- 리눅스 네임스페이스(Linux Namespaces) : 각 프로세스가 시스템에 독립 뷰 제공
- 리눅스 컨트롤그룹(cgrops) : 프로세스가 소비할 수 있는 리소스 양 제한

#### 도커?
- 애플리케이션 패키징, 배포, 실행 플랫폼
- 주요 3개념 : 이미지, 레지스트리, 컨테이너
- 도커의 이미지는 레이어로 구성되어있다. 레이어는 이미지 저장공간을 줄이는데 도움이 된다.

## 쿠버네티스

- 컨테이너 시스템에서 컨테이너 애플리케이션을 쉽게 배포하고 관리할 수 있게 해주는 소프트웨어 시스템이다. 
- 쿠버네티스 시스템은 마스터 노드와 여러개의 워커 노드로 구성된다.
- 만약 특정 애플리케이션을 실행한다고 하면, 쿠버네티스는 동일한 워커노드에 배포되고, 다른 애플리케이션은 클러스터 주위에 분산되어 있다. 그래서 배포위치와는 상관없이 동일한 방식으로 서로 통신이 가능하다.

#### 쿠버네티스 클러스터 아키텍처 구성
- 컨트롤 플레인 : 클러스터 관리 및 클러스터 기능실행
  - 쿠버네티서 API서버 : 유저 및 컨트롤 플레인과 통신
  - 스케줄러(Scheduler) : 애플리케이션 예약
  - 컨트롤러 매니저(Controller Manager) : 구성요소 복제, 워커 노드 추적, 노드 장애처리 등 클러스터 수준기능 실행
  - etcd : 분산 데이터 스토리지

- 노드 : 애플리케이션 실행 시스템
  - 도커 or 컨테이너 런타임 : 컨테이너 실행
  - Kubelet : API서버와 통신 및 노드에서 컨테이너 관리
  - Kube-proxy : 네트워크 트래픽 분산

## 쿠버네티스의 장점

- 쿠버네티스가 배포된 노드에서는 시스템 관리자의 도움없이 즉시 애플리케이션 실행가능 (설치X)